```


*前言：
  从词法分析，到语法分析，到三地址代码生成，这个几个阶段的本质还只是对字符串的转换，是静态编译阶段。而运行时指的是程序执行顺序、执行环境、内存动态分配等内容。
  运行时刻跟编译时刻虽然是两个不同的阶段，但是由于运行时刻用到的指令是由编译器生成的，要使编译器生成正确指令，必需对程序运行时有足够的了解。如此才能解决在前面一节《03_中间代码生成》的三地址表达式实例2中提出的问题，才能生成能够翻译为机器码的精确中间码


*运行时刻环境的主要内容：
·运行存储分配
·作用域
·全局环境
·垃圾回收


*运行存储分配：
·运行时内存的划分:
  -- 操作系统给内存进行规划，将内存大概分成操作系统内核内存和给程序员使用的内存2大部分。
  -- 这样的好处是：操作系统的内存不会被大量占用，避免机器卡住、卡死、死机等状态，可通过操作系统把应用程序关闭，使得操作系统更安全。
·运行存储分配策略：
  -- 静态存储分配：数据对象大小确定，编译器在编译时刻就可以做出存储分配决定，不需要考虑程序运行时刻的情形。例如全局常量、全局变量就可以采用静态存储分配
  -- 动态存储分配：数据对象大小不确定，在运行时才能进行内存分配
     -- 栈式存储分配：
     -- 堆式存储分配：用于存放生命周期不确定、或生存到被明确删除为止的数据对象。例如：new生成的对象可以生存到等于null为止
·栈内存和堆内存的本质区别：
  -- 栈内存和堆内存在物理上都是一样的，都是物理内存的一部分，只不过是操作系统将虚拟内存进行了抽象分类取名
  -- 操作系统为何要将内存分为栈内存和堆内存呢？
     
·影响运行存储分配策略的因素：
  -- 是否需要支持递归？
     -- 不需要支持：可以采用静态存储分配策略，例如：BASIC和FORTRAN等
     -- 需要支持：采用动态存储分配策略，因为递归意味着一个时刻可能有多个活动同时存在，例如：JS和JAVA等
·对于支持递归语言的内存具体规划，从低位到高位分别是：可参考图《递归语言的运行时内存划分.jpg》
  -- 代码段（文本段）：函数编译成opcode(二进制)后存到磁盘，运行时将二进制从磁盘加载到内存中。
  -- 数据段（静态空间）：全局变量、常量、静态变量存数据段
  -- 堆：比栈内存大得多，一般有几G大小。
  -- 自由可分配内存：运行时逐渐被堆栈占据，运行完后数据释放空间恢复
  -- 栈：第一个函数运行时压入栈底，函数调新函数时再往栈里压入该新函数，新函数运行完即出栈，第一个函数运行完再出栈，栈为空
  -- 内核
·关于程序调用的系统栈的分析：当函数A执行到第2行时，开始运行函数B，此时A停止开始运行B，并向系统栈中压入A2（表示函数A的第2行），当B执行到第2行时开始运行函数C，并在系统栈中压入B2，当C运行完时再查看系统栈，发现了B2，系统开始继续执行B的第2行，B执行完后查看系统栈，发现A2，则继续执行A直到完成。


*全局运行环境：
·除了程序员自身写的代码外，程序自身会自带一个全局运行环境，例如js中在浏览器中的window对象，在node环境中的global对象
·全局运行环境的组成：
  -- hashmap：{}
  -- level：0  //环境当前的嵌套层级，初始为0
  -- parent：sp  //子环境（字作用域）指向父环境的指针


*作用域
·作用域分为：词法作用域和环境作用域（执行时作用域/动态作用域）
·词法作用域：在词法分析时就可以知道一个变量的作用域，如果是有一个作用域，则创建一个block，满足“最近嵌套原则”，并形成一个作用域链
·子作用域：js在调用函数时会创建一个子环境，并且，父环境对象作为一个参数传入这个子环境对象创建当中，这个子环境就是一个子作用域
·词法闭包：在词法分析时就可以知道闭包的存在


*递归活动分析：
·三地址表达式实例2（斐波那契函数）栈的运行图示：
    栈空间（通过指针偏移拿到数据）     代码段空间（通过行号值拿到数据）    
  |  link7   |                           
  //link7会指向数字2                |     f    |
  |     2    |                     |  t1=n==1  |
  |  link6   |                     |  t2=n==2  |
  |  link5   |                     |t3=t1 or t2|
  |其他临时变量|                    |           |
  |  返回值3 |                      |branch goto|
  |     3    |                     |   ...     |
  |  link4   |                     |           |
  |  link3   |                     |           |
  |其他临时变量|                    |           |
  |  返回值2 |                      |          |
  |     4    |                     |           |
  |  link2   |                     |           |
  //link2会指向数字5                |           |
  |  link1   |                     |           |
  //link1会指向代码call f           |           |
  |其他临时变量|                    |           |
  |  返回值1 |                      |          |
  //返回值可根据5的偏移量计算拿到     |  call f  |
  |     5    |                     //call f将指向第一行f
  ------------                     --------------
·定义三地址码生成规则：
  -- @：表示作用域
  -- set：赋值
  -- branch：if语句判断
  -- $：临时变量
  -- call：调用函数
  -- section：区块
  -- %:寄存器，%TOP%表示TOP寄存器
  -- SP：指针
  -- call：函数调用
  -- pass：表示传参
·源码 → 三地址
  function fibonacci(n){
    if(n==1 || n==2){
      return n
    }
    return fibonacci(n-1)+fibonacci(n-2)
  }
  print(fibonacci(5))
  转换后的三地址码：
    section fibonacci@2
    set %TOP% %SP%
    set $t1@2 n==1
    set $t2@2 n==2
    set $t3@2 $t1@2 || $t2@2
    branch $t3@2 LB1  //$t3@2为true时继续，否则跳转到LB1行
    return n@2
    LB1:set $t4@2 n-1
    pass $t4@2    //pass表示传参，压栈
    call fibonacci@1
    set $6@2 n-2
    pass $t6@2    //pass表示传参，压栈
    call fibonacci@1
    set $t8@2 $t5@2 + $t7@2
    return $t8@2@2
    section main@1
    set %TOP% %SP%
    declare function fibonacci@1
    pass 5
    call fibonacci@1
    pass $t2@1
    call print@1


